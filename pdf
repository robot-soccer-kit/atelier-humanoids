<h1 id="robot-soccer-kit---programme-ton-robot-footballeur">Robot Soccer Kit - Programme ton robot footballeur</h1>
<h2 id="introduction">Introduction</h2>
<p>Dans ce projet, vous allez apprendre à programmer des robots omnidirectionnels (qui peuvent se déplacer dans toutes les directions) afin qu’ils jouent au football.</p>
<h2 id="appréhension-de-lenvironnement-de-programmation-et-du-kit">Appréhension de l’environnement de programmation et du kit</h2>
<h3 id="lancement-du-simulateur">Lancement du simulateur</h3>
<p>Pour lancer le simulateur, il suffit de double cliquer sur l’icône <img src="./img/RSK_simu.ico" width="30"> sur le Bureau.</p>
<p>Une autre possibilité est de lancer la commande suivante dans un terminal <img src="./img/terminal.png" width="25"> :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ex">python</span> -m rsk.game_controller -s</span></code></pre></div>
<p>Cela ouvrira une fenêtre de simulation dans un navigateur avec un terrain de football, quatre robots, une balle ainsi que l’interface d’arbitrage telle que présentée ci-dessous.</p>
<figure>
<img src="./img/referee.png" alt="" /><figcaption>Simulation Interface</figcaption>
</figure>
<p>Si vous fermez le navigateur par inadvertance, l’interface reste accessible en réouvrant le navigateur et en allant à l’adresse <a href="http://127.0.0.1:7070"><code>http://127.0.0.1:7070</code></a>.</p>
<h3 id="lancement-de-linterface-de-programmation">Lancement de l’interface de programmation</h3>
<p>Dans ce tutoriel, nous allons utiliser Visual Studio Code afin de programmer les robots grâce à Python.</p>
<ol type="1">
<li><p>Ouvrez Visual Studio Code en double cliquant sur l’icône <img src="./img/vscode.png" width="25"> sur le Bureau.</p></li>
<li><p>Ouvrez le dossier où se trouvent tous les programmes du projet en cliquant sur <code>Fichier</code> puis <code>Ouvrir Dossier...</code> et en sélectionnant le dossier <code>Programmes-RobotSoccerKits</code> sur le Bureau.</p></li>
</ol>
<h3 id="création-dun-nouveau-fichier">Création d’un nouveau fichier</h3>
<p>Pour créer un nouveau fichier, il suffit de faire un clic droit dans la zone à gauche, sur le dossier Code, et de cliquer sur <code>New File...</code>, puis d’entrer le nom du fichier, en le terminant par .py, car nous programmons ici en Python.</p>
<figure>
<img src="./img/new_file.png" alt="" /><figcaption>New file</figcaption>
</figure>
<p>Si la zone n’apparait pas, cliquer sur l’icone : <img src="./img/explorer.png" width="35"></p>
<h3 id="lancement-dun-programme">Lancement d’un programme</h3>
<p>Pour lancer un programme, cliquer sur le petit triangle play encadré en rouge ci-dessous :</p>
<figure>
<img src="./img/play.png" alt="" /><figcaption>Play</figcaption>
</figure>
<p>Une fenêtre de terminal apparait alors en bas de l’écran.</p>
<figure>
<img src="./img/ecran.png" alt="" /><figcaption>Ecran</figcaption>
</figure>
<h3 id="arrêter-un-programme">Arrêter un programme</h3>
<p>Enfin pour couper un programme, cliquer sur la petite poubelle (entourée en rouge ci-dessous) dans la partie terminal</p>
<figure>
<img src="./img/poubelle.png" alt="" /><figcaption>Poubelle</figcaption>
</figure>
<h2 id="introduction-à-la-programmation-des-robots">Introduction à la programmation des robots</h2>
<h2 id="première-partie-implémentation-dun-robot-défenseur">Première partie : Implémentation d’un robot défenseur</h2>
<h3 id="objectif">Objectif</h3>
<p>Le but de cette première partie est de programmer un robot défenseur qui doit empêcher l’équipe adverse de marquer un but.</p>
<h3 id="suivi-de-la-balle-en-y">1. Suivi de la balle en Y</h3>
<p>Voici un exemple de code permettant de faire en sorte que le robot Green1 suive la balle selon l’axe x.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>):<span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>    client.green1.goto((client.ball[<span class="dv">0</span>], <span class="fl">0.0</span>, math.radians(<span class="op">-</span><span class="dv">90</span>)))<span class="co">#Déplace le robot Green1 à la position actuelle de la balle selon l&#39;axe x, en restant sur la droite où y = 0, et oriente le robot vers le bas</span></span></code></pre></div>
<p>Pour information,</p>
<p>La fonction <code>client.green1.goto()</code> prend 3 arguments :</p>
<ul>
<li>la position en x (ici <code>client.ball[0]</code> )</li>
<li>la position en y (ici <code>0.0</code> )</li>
<li>l’orientation (ici <code>math.radians(-90)</code>, c’est-à-dire orienté vers le bas)</li>
</ul>
<p>On peut remarquer que l’on utilise la fonction math.radians() afin de convertir une valeur en degré en valeur en radian. Pour utiliser cette fonction, nous avons besoin de la bibliothèque math, que l’on importe ligne 2 avec <code>import math</code></p>
<p>De plus,</p>
<ul>
<li><p><code>client.ball[0]</code> correspond à la position de la balle en x</p></li>
<li><p><code>client.ball[1]</code> correspond à la position de la balle en y</p></li>
</ul>
<p>La première étape est de réussir à suivre la balle selon l’axe y, de manière à bloquer un éventuel tir ennemi.</p>
<ol type="1">
<li>Modifier les arguments de la fonction <code>client.green1.goto()</code> afin de suivre la balle selon l’axe y, en restant sur la ligne médiane (c’est-à-dire la droite où x = 0).</li>
</ol>
<p>On peut alors remarquer une latence entre le moment où la balle bouge et le moment où le robot bouge. Cela est dû au caractère blocant de la fonction goto(). En effet, la fonction <code>goto()</code>, sans l’argument <code>wait=False</code>, est une fonction blocante, ce qui signifie qu’elle bloque le programme jusqu’à être réalisée, même si la balle n’est plus à la position demandée. Donc, lorsqu’on utilise la fonction <code>goto()</code> sans argument <code>wait=False</code>, le robot aura toujours un temps de retard : il va toujours se déplacer vers l’ancienne position de la balle.</p>
<p>Voici l’exemple initial, en ajoutant l’argument <code>wait=False</code> :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>):<span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    client.green1.goto((client.ball[<span class="dv">0</span>], <span class="fl">0.0</span>, math.radians(<span class="op">-</span><span class="dv">90</span>)),wait<span class="op">=</span><span class="va">False</span>)<span class="co">#Déplace le robot Green1 à la position actuelle de la balle selon l&#39;axe x, en restant sur la droite où y = 0, et oriente le robot vers le bas</span></span></code></pre></div>
<ol start="2" type="1">
<li>Ajouter l’argument <code>wait=False</code> aux arguments de la fonction <code>client.green1.goto()</code> du programme fait au 1. afin de régler ce problème.</li>
</ol>
<p>Enfin, de nombreuses constantes ont été définies de manière à simplifier le développement sur RSK. On les retrouve dans la sous-bibliothèque constants de la bibliothèque RSK. Pour les importer, il suffit d’utiliser : <code>from rsk import constants</code></p>
<p>La liste des constantes déjà implémentées est disponible ici : https://github.com/robot-soccer-kit/robot-soccer-kit/blob/master/rsk/constants.py</p>
<p>Une fois la bibliothèque implémentée avec <code>from rsk import constants</code>, on peut également retrouver ses différentes constantes et fonctions sur VSCode en tapant <code>constants.</code> <img src="./img/constants.png" alt="Autocompletion VSCode" /></p>
<ol start="3" type="1">
<li>L’étape suivante sera de faire suivre la balle au robot en y, tout en suivant la ligne de but (c’est-à-dire la droite où x = <code>constants.field_length/2</code>).</li>
</ol>
<h3 id="rester-dans-les-cages">2. Rester dans les cages</h3>
<p>On aimerait désormais que le robot défenseur ne quitte pas la zone du gardien et reste entre ses poteaux.</p>
<p>Pour cela, nous allons venir vérifier qu’il ne sort pas des buts à l’aide d’une instruction conditionnelle (On demande au robot de faire quelque chose SI une condition est vérifiée). Nous allons donc utiliser une instruction de type IF/ELIF/ELSE (cf. la partie <strong>Conditions et Boucles</strong> du <em>Memo Python</em> pour plus d’explications)</p>
<p>En voici un exemple, complétant l’exemple précédent, permettant d’empêcher le robot de sortir de son coté du terrain :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>): <span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="cf">if</span> client.ball[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="fl">0.0</span>: <span class="co">#Si la balle est dans la zone de l&#39;équipe verte</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        client.green1.goto((client.ball[<span class="dv">0</span>], <span class="fl">0.0</span>, math.radians(<span class="op">-</span><span class="dv">90</span>)), wait<span class="op">=</span><span class="va">False</span>) <span class="co">#Déplace le robot Green1 à la position actuelle de la balle selon l&#39;axe x, et oriente le robot vers le bas</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="cf">else</span>: <span class="co">#Sinon</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        client.green1.goto((<span class="fl">0.5</span>, <span class="fl">0.0</span>, math.radians(<span class="op">-</span><span class="dv">90</span>)), wait<span class="op">=</span><span class="va">False</span>)<span class="co">#Déplace le robot Green1 à la position [0.5,0.0], et oriente le robot vers le bas</span></span></code></pre></div>
<p>Il est également possible de ne pas mettre de <code>else</code>, le robot ne fera alors rien si la condition n’est pas remplie (Il restera à sa position)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>):<span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="cf">if</span> client.ball[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="fl">0.0</span>: <span class="co">#Si la balle est dans la zone de l&#39;équipe verte</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>        client.green1.goto((client.ball[<span class="dv">0</span>], <span class="fl">0.0</span>, math.radians(<span class="op">-</span><span class="dv">90</span>)),wait<span class="op">=</span><span class="va">False</span>)<span class="co">#Déplace le robot Green1 à la position actuelle de la balle selon l&#39;axe x, et oriente le robot vers le bas</span></span></code></pre></div>
<p>Nous aimerions donc que le robot ne sorte pas de sa ligne de gardien, en restant entre le poteau haut (<code>y = constants.goal_width/2</code>) et le poteau bas (<code>y = -constants.goal_width/2</code>)</p>
<ol type="1">
<li>Adapter le code de suivi de la balle en Y pour empêcher le robot de sortir des buts.</li>
</ol>
<h3 id="bonus-intersectionner-la-trajectoire-de-lattaquant">3. BONUS : Intersectionner la trajectoire de l’attaquant</h3>
<p>Nous avons désormais un gardien basique, qui reste dans ses cages, capable d’arrêter les tirs horizontaux.</p>
<p>Cependant, il est possible que l’attaquant fasse des tirs diagonaux, qui seront difficilement arrêtés par notre gardien actuel.</p>
<p>La solution devient alors de placer le robot dans la trajectoire de l’attaquant.</p>
<p>Pour se faire, il faut réussir à le placer sur la droite passant par l’attaquant et la balle.</p>
<p>En manipulant la géométrie, on obtient :</p>
<p><span class="math inline">$y_{defenseur} = \frac{(y_{attaquant} - y_{balle})}{(x_{attaquant} - x_{balle})} \times x_{defenseur} + y_{balle}$</span></p>
<p>Ne reste alors qu’une dernière étape :</p>
<ol type="1">
<li>Modifier la fonction précédente afin de déplacer le robot à l’intersection entre la trajectoire de l’attaquant et la ligne de but. Un exemple de code à compléter vous est également proposé ci-dessous.</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="im">from</span> rsk <span class="im">import</span> constants</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>):<span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    xb1 <span class="op">=</span> client.blue1.position[<span class="dv">0</span>]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    yb1 <span class="op">=</span> client.blue1.position[<span class="dv">1</span>]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    xballe <span class="op">=</span> client.ball[<span class="dv">0</span>]</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    yballe <span class="op">=</span> client.ball[<span class="dv">1</span>]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    <span class="cf">if</span> xballe <span class="op">&gt;</span> xb1: <span class="co">#Si l&#39;attaquant est plus avancé que la balle, il ne peut pas tirer, donc pas besoin de se déplacer</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>        pente <span class="op">=</span> (yb1<span class="op">-</span>yballe)<span class="op">/</span>(xb1<span class="op">-</span>xballe)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        xg1 <span class="op">=</span> constants.field_length<span class="op">/</span><span class="dv">2</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>        yg1 <span class="op">=</span> ...</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>        </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>        <span class="cf">if</span> yg1 <span class="op">&gt;</span> ... :</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>            client.green1.goto((xg1, constants.goal_width<span class="op">/</span><span class="dv">2</span>, math.radians(<span class="dv">180</span>)),wait<span class="op">=</span><span class="va">False</span>)<span class="co">#Déplace le robot Green1 à son poteaux haut, et oriente le robot vers la gauche</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>        <span class="cf">elif</span> yg1 <span class="op">&lt;</span> <span class="op">-</span>... :</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>            client.green1.goto((xg1, <span class="op">-</span>constants.goal_width<span class="op">/</span><span class="dv">2</span>, math.radians(<span class="dv">180</span>)),wait<span class="op">=</span><span class="va">False</span>)<span class="co">#Déplace le robot Green1 à son poteaux bas, et oriente le robot vers la gauche</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>            client.green1.goto((xg1, yg1, math.radians(<span class="dv">180</span>)),wait<span class="op">=</span><span class="va">False</span>)<span class="co">#Déplace le robot Green1 à la position actuelle de la balle selon l&#39;axe y, et oriente le robot vers la gauche</span></span></code></pre></div>
<h3 id="conclusion-partie-défenseur">Conclusion Partie Défenseur</h3>
<p>Nous avons désormais un gardien coté vert capable de défendre notre but face à l’attaquant blue1.</p>
<p>Cependant, plusieurs problèmes subsistent :</p>
<ul>
<li><p>notre gardien n’est pas programmé pour défendre contre l’autre joueur bleu.</p></li>
<li><p>nous n’avons pas de stratégie de contre-attaque pas.</p></li>
</ul>
<p>On pourrait également implémenter des stratégies à deux joueurs, pour faire des passes, et faire sortir le gardien de sa ligne de but, afin d’aller chercher la balle.</p>
<p>Toute ces problématiques n’entrent pas dans le cadre de cet atelier, dont le but est de proposer une introduction à la programmation Python avec RSK, mais pourront être adressées par les plus dévoués.</p>
<h2 id="deuxième-partie-implémentation-dun-robot-attaquant">Deuxième partie : Implémentation d’un robot attaquant</h2>
<h3 id="objectif-1">Objectif</h3>
<p>Dans cette seconde partie, nous allons programmer un robot attaquant qui doit tenter de marquer des buts.</p>
<p>Afin de pouvoir jouer contre notre robot défenseur, nous allons maintenant nous placer du coté bleu mais on pourrait également implémenter cet attaquant coté vert.</p>
<h3 id="attaque-face-aux-cages">1. Attaque face aux cages</h3>
<p>Pour commencer, nous allons implémenter un tir horizontal face aux cages.</p>
<p>Voici un exemple de code permettant de tirer vers le bas :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="im">from</span> rsk <span class="im">import</span> constants</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>):<span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé    </span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    client.blue1.goto((client.ball[<span class="dv">0</span>], client.ball[<span class="dv">1</span>]<span class="op">+</span>constants.robot_radius, math.radians(<span class="op">-</span><span class="dv">90</span>)))<span class="co">#Déplace le robot derrière la balle, orienté vers le bas</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    client.blue1.kick() <span class="co">#Tire</span></span></code></pre></div>
<p>On remarquera l’absence de l’argument <code>wait=False</code>, car on souhaite que le robot finisse son déplacement avant de tirer.</p>
<p>(On aurait également pu augmenter la réactivité de l’attaquant en mettant l’argument <code>wait=False</code> et en venant vérifier la distance entre le robot et la balle, mais pour des raisons de simplicité, nous ne metterons juste pas l’argument <code>wait=False</code>)</p>
<ol type="1">
<li>Modifier les arguments de la fonction <code>client.blue1.goto()</code> afin de se placer et s’orienter pour tirer vers les cages vertes (c’est-à-dire à gauche de la balle, orienté à 0°)</li>
</ol>
<h3 id="tir-vers-les-buts-selon-3-couloirs">2. Tir vers les buts selon 3 couloirs</h3>
<p>Nous avons maintenant un robot attaquant capable de tirer de manière horizontale. Cependant, si le robot n’est pas aligné avec les cages, le tir ne sera pas cadré.</p>
<p>Pour régler ce problème, nous devons implémenter des tirs diagonaux.</p>
<p>Pour commencer, nous allons implémenter 3 différents tirs :</p>
<ul>
<li>un tir à -45° si nous sommes au dessus des cages (ci-dessous en rouge)</li>
<li>un tir à 0° si nous sommes en face des cages (ci-dessous en jaune)</li>
<li>un tir à 45° si nous sommes en dessous des cages (ci-dessous en bleu)</li>
</ul>
<figure>
<img src="./img/zones.png" alt="" /><figcaption>Zones</figcaption>
</figure>
<p>Pour se faire nous allons commencer par faire une distinction de cas avec des instructions IF/ELIF/ELSE comme dans la partie 2 du robot défenseur.</p>
<p>Puis, selon le cas nous choisirons le tir le plus adapté.</p>
<ol type="1">
<li>Compléter le code ci-dessous</li>
</ol>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="im">from</span> rsk <span class="im">import</span> constants</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>):<span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé    </span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>    <span class="cf">if</span> client.ball[<span class="dv">1</span>] <span class="op">&gt;</span> constants.goal_width<span class="op">/</span><span class="dv">2</span>: <span class="co"># Si la balle est au dessus du but</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>        orientation <span class="op">=</span> ...</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>        client.blue1.goto((client.ball[<span class="dv">0</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.cos(orientation), client.ball[<span class="dv">1</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.sin(orientation), math.radians(orientation)))<span class="co">#Déplace le robot derrière la balle, orienté à orientation°</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    <span class="cf">elif</span> client.ball[<span class="dv">1</span>] <span class="op">&lt;</span> <span class="op">-</span>constants.goal_width<span class="op">/</span><span class="dv">2</span>: <span class="co"># Si la balle est en dessous du but</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>        orientation <span class="op">=</span> ...</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>        client.blue1.goto((client.ball[<span class="dv">0</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.cos(orientation), client.ball[<span class="dv">1</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.sin(orientation), math.radians(orientation)))<span class="co">#Déplace le robot derrière la balle, orienté à orientation°</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>        orientation <span class="op">=</span> ...</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>        client.blue1.goto((client.ball[<span class="dv">0</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.cos(orientation), client.ball[<span class="dv">1</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.sin(orientation), math.radians(orientation)))<span class="co">#Déplace le robot derrière la balle, orienté à orientation°</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>    client.blue1.kick() <span class="co">#Tire</span></span></code></pre></div>
<h3 id="tir-vers-les-but-de-manière-continue-selon-une-infinité-de-couloirs">3. Tir vers les but de manière continue (selon une infinité de couloirs)</h3>
<p>Notre robot peut maintenant tirer selon 3 couloirs. Mais pourquoi se limiter à 3 couloirs, on pourrait le faire tirer selon n’importe quelle orientation.</p>
<p>Pour cela, nous allons implémenter l’orientation de manière continue.</p>
<p>Où que soit le robot sur le terrain, nous allons le faire tirer vers le milieu des cages.</p>
<p>Pour se faire, un peu de trigonométrie nous donne :</p>
<p><span class="math inline">$orientation = arctan(\frac{(y_{but} - y_{balle})}{(x_{but} - x_{balle})})$</span></p>
<p>Ne reste alors qu’à implémenter cela.</p>
<ol type="1">
<li>Compléter le code ci-dessous</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="im">import</span> math</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="im">import</span> rsk</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="im">from</span> rsk <span class="im">import</span> constants</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>client <span class="op">=</span> rsk.Client() <span class="co">#Crée un client Robot Soccer Kit, contenant nombre de variables utiles </span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="cf">while</span>(<span class="dv">1</span>):<span class="co">#Boucle infinie permettant d&#39;actualiser l&#39;ordre demandé    </span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="co">#Position du milieu des buts [constants.field_length/2 ; 0.0]</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    <span class="co">#La fonction arctan est disponible dans la bibliothèque math, en utilisant la fonction math.atan()</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>    orientation <span class="op">=</span> math.atan(...)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>    client.blue1.goto((client.ball[<span class="dv">0</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.cos(orientation), client.ball[<span class="dv">1</span>]<span class="op">-</span>constants.robot_radius<span class="op">*</span>math.sin(orientation), orientation))<span class="co">#Déplace le robot derrière la balle, orienté à orientation°</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>    client.blue1.kick() <span class="co">#Tire</span></span></code></pre></div>
<h3 id="conclusion-partie-attaquant">Conclusion Partie Attaquant</h3>
<p>Nous avons donc maintenant un attaquant capable de tirer selon une infinité d’angles.</p>
<p>Des problèmes persistent néanmoins :</p>
<ul>
<li>L’attaquant tire toujours au milieu des cages, la défense est donc aisé, un plot placé au milieu des cages suffirait pour défendre.</li>
<li>Le robot n’évite pas la balle lorsqu’il se place, et peut potentiellement la déplacer par inadvertance.</li>
</ul>
<p>Nous pourrions également programmer des stratégies permettant de faire des passes afin de déstabiliser l’équipe adverse.</p>
<p>Ces problématiques ne sont pas dans le cadre de cet atelier, mais pourront être adressées par les plus dévoués.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Nous avons donc programmé les RSK de manière à avoir un attaquant bleu et un défenseur vert.</p>
<p>En modifiant légèrement le code, nous pourrions avoir une équipe composé d’un attaquant et d’un défenseur et faire des matchs.</p>
<p>De nombreuses problématiques n’ont pas été résolues lors de cet atelier, dont le but était l’introduction à RSK, et sont laissées en exercice à ceux qui le veulent.</p>
